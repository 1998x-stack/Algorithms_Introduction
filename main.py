structure = {
    "01._基础知识": {
        "1.1_引言": [],
        "1.2_算法在计算中的角色": [
            "1.2.1_算法",
            "1.2.2_算法作为一项技术"
        ],
        "1.3_开始": [
            "1.3.1_插入排序",
            "1.3.2_分析算法",
            "1.3.3_设计算法"
        ],
        "1.4_运行时间的表征": [
            "1.4.1_O_符号_Ω_符号和Θ_符号",
            "1.4.2_渐进符号的正式定义",
            "1.4.3_标准符号和常用函数"
        ],
        "1.5_分治法": [
            "1.5.1_矩阵乘法",
            "1.5.2_Strassen_算法",
            "1.5.3_递归方程的替代方法",
            "1.5.4_递归树方法",
            "1.5.5_主方法",
            "1.5.6_连续主定理的证明",
            "1.5.7_Akra_Bazzi_递归"
        ],
        "1.6_概率分析和随机算法": [
            "1.6.1_招聘问题",
            "1.6.2_指示随机变量",
            "1.6.3_随机算法",
            "1.6.4_概率分析和指示随机变量的进一步使用"
        ]
    },
    "02._排序和顺序统计": {
        "2.1_引言": [],
        "2.2_堆排序": [
            "2.2.1_堆",
            "2.2.2_维护堆性质",
            "2.2.3_建堆",
            "2.2.4_堆排序算法",
            "2.2.5_优先队列"
        ],
        "2.3_快速排序": [
            "2.3.1_快速排序描述",
            "2.3.2_快速排序性能",
            "2.3.3_随机化版本的快速排序",
            "2.3.4_快速排序分析"
        ],
        "2.4_线性时间排序": [
            "2.4.1_排序的下限",
            "2.4.2_计数排序",
            "2.4.3_基数排序",
            "2.4.4_桶排序"
        ],
        "2.5_中位数和顺序统计": [
            "2.5.1_最小和最大",
            "2.5.2_预期线性时间选择",
            "2.5.3_最坏情况线性时间选择"
        ]
    },
    "03._数据结构": {
        "3.1_引言": [],
        "3.2_基本数据结构": [
            "3.2.1_简单数组结构_数组_矩阵_栈_队列",
            "3.2.2_链表",
            "3.2.3_根树的表示"
        ],
        "3.3_哈希表": [
            "3.3.1_直接地址表",
            "3.3.2_哈希表",
            "3.3.3_哈希函数",
            "3.3.4_开放地址法",
            "3.3.5_实际考虑"
        ],
        "3.4_二叉搜索树": [
            "3.4.1_什么是二叉搜索树",
            "3.4.2_查询二叉搜索树",
            "3.4.3_插入和删除"
        ],
        "3.5_红黑树": [
            "3.5.1_红黑树的性质",
            "3.5.2_旋转",
            "3.5.3_插入",
            "3.5.4_删除"
        ]
    },
    "04._高级设计和分析技术": {
        "4.1_引言": [],
        "4.2_动态规划": [
            "4.2.1_切杆问题",
            "4.2.2_矩阵链乘法",
            "4.2.3_动态规划的元素",
            "4.2.4_最长公共子序列",
            "4.2.5_最优二叉搜索树"
        ],
        "4.3_贪心算法": [
            "4.3.1_活动选择问题",
            "4.3.2_贪心策略的元素",
            "4.3.3_霍夫曼编码",
            "4.3.4_离线缓存"
        ],
        "4.4_均摊分析": [
            "4.4.1_聚合分析",
            "4.4.2_记账方法",
            "4.4.3_潜能方法",
            "4.4.4_动态表"
        ]
    },
    "05._高级数据结构": {
        "5.1_引言": [],
        "5.2_增强数据结构": [
            "5.2.1_动态顺序统计",
            "5.2.2_如何增强数据结构",
            "5.2.3_区间树"
        ],
        "5.3_B_树": [
            "5.3.1_B_树的定义",
            "5.3.2_B_树的基本操作",
            "5.3.3_从_B_树中删除键"
        ],
        "5.4_不相交集的数据结构": [
            "5.4.1_不相交集操作",
            "5.4.2_不相交集的链表表示",
            "5.4.3_不相交集的森林",
            "5.4.4_使用路径压缩和按秩合并的分析"
        ]
    },
    "06._图算法": {
        "6.1_引言": [],
        "6.2_基本图算法": [
            "6.2.1_图的表示",
            "6.2.2_广度优先搜索",
            "6.2.3_深度优先搜索",
            "6.2.4_拓扑排序",
            "6.2.5_强连通分量"
        ],
        "6.3_最小生成树": [
            "6.3.1_最小生成树的生长",
            "6.3.2_Kruskal_和_Prim_算法"
        ],
        "6.4_单源最短路径": [
            "6.4.1_Bellman_Ford_算法",
            "6.4.2_有向无环图中的单源最短路径",
            "6.4.3_Dijkstra_算法",
            "6.4.4_差分约束和最短路径",
            "6.4.5_最短路径性质的证明"
        ],
        "6.5_所有节点对最短路径": [
            "6.5.1_最短路径和矩阵乘法",
            "6.5.2_Floyd_Warshall_算法",
            "6.5.3_稀疏图的_Johnson_算法"
        ],
        "6.6_最大流": [
            "6.6.1_流网络",
            "6.6.2_Ford_Fulkerson_方法",
            "6.6.3_最大二分匹配"
        ],
        "6.7_二分图匹配": [
            "6.7.1_最大二分匹配_重新审视",
            "6.7.2_稳定婚姻问题",
            "6.7.3_分配问题的匈牙利算法"
        ]
    },
    "07._精选专题": {
        "7.1_引言": [],
        "7.2_并行算法": [
            "7.2.1_Fork_join_并行的基础",
            "7.2.2_并行矩阵乘法",
            "7.2.3_并行合并排序"
        ],
        "7.3_在线算法": [
            "7.3.1_等待电梯",
            "7.3.2_维护搜索列表",
            "7.3.3_在线缓存"
        ],
        "7.4_矩阵运算": [
            "7.4.1_线性方程组的求解",
            "7.4.2_矩阵求逆",
            "7.4.3_对称正定矩阵和最小二乘近似"
        ],
        "7.5_线性规划": [
            "7.5.1_线性规划的形式和算法",
            "7.5.2_线性规划问题的建模",
            "7.5.3_对偶性"
        ],
        "7.6_多项式和FFT": [
            "7.6.1_多项式的表示",
            "7.6.2_DFT和FFT",
            "7.6.3_FFT电路"
        ],
        "7.7_数论算法": [
            "7.7.1_基本数论概念",
            "7.7.2_最大公约数",
            "7.7.3_模运算",
            "7.7.4_求解模线性方程",
            "7.7.5_中国剩余定理",
            "7.7.6_元素的幂",
            "7.7.7_RSA公钥密码系统",
            "7.7.8_素性测试"
        ],
        "7.8_字符串匹配": [
            "7.8.1_朴素字符串匹配算法",
            "7.8.2_Rabin_Karp_算法",
            "7.8.3_使用有限自动机的字符串匹配",
            "7.8.4_Knuth_Morris_Pratt_算法",
            "7.8.5_后缀数组"
        ],
        "7.9_机器学习算法": [
            "7.9.1_聚类",
            "7.9.2_乘法权重算法",
            "7.9.3_梯度下降"
        ],
        "7.10_NP_完全性": [
            "7.10.1_多项式时间",
            "7.10.2_多项式时间验证",
            "7.10.3_NP_完全性和可归约性",
            "7.10.4_NP_完全性证明",
            "7.10.5_NP_完全问题"
        ],
        "7.11_近似算法": [
            "7.11.1_顶点覆盖问题",
            "7.11.2_旅行商问题",
            "7.11.3_集合覆盖问题",
            "7.11.4_随机化和线性规划",
            "7.11.5_子集和问题"
        ]
    },
    "08._附录_数学背景": {
        "8.1_引言": [],
        "8.2_求和": [
            "8.2.1_求和公式和性质",
            "8.2.2_求和的界限"
        ],
        "8.3_集合等": [
            "8.3.1_集合",
            "8.3.2_关系",
            "8.3.3_函数",
            "8.3.4_图",
            "8.3.5_树"
        ],
        "8.4_计数和概率": [
            "8.4.1_计数",
            "8.4.2_概率",
            "8.4.3_离散随机变量",
            "8.4.4_几何分布和二项分布",
            "8.4.5_二项分布的尾部"
        ],
        "8.5_矩阵": [
            "8.5.1_矩阵和矩阵运算",
            "8.5.2_基本矩阵性质"
        ]
    },
}



import os
from typing import Dict, Any

def create_directories_and_files(
        base_path: str, 
        structure: Dict[str, Any], 
        readme_file, 
        parent_path: str = "", 
        level: int = 1
    ):
    heading = "#" * level

    for key, value in structure.items():
        current_path = os.path.join(base_path, key.replace(" ", "_").replace("/", "_").replace("-", "_"))

        # 创建目录
        os.makedirs(current_path, exist_ok=True)

        # 在README中添加章节标题
        if parent_path:
            readme_file.write(f"{heading} {parent_path}/{key}\n\n")
        else:
            readme_file.write(f"{heading} {key}\n\n")

        # 递归调用创建子目录和文件
        if isinstance(value, dict) and value:
            create_directories_and_files(
                current_path, 
                value, 
                readme_file, 
                parent_path + "/" + key if parent_path else key, 
                level + 1
            )
        elif isinstance(value, list) and value:
            for idx, item in enumerate(value):
                if isinstance(item, dict) and item:
                    create_directories_and_files(
                        current_path, 
                        item, 
                        readme_file, 
                        parent_path + "/" + key if parent_path else key, 
                        level + 1
                    )
                else:
                    item = f"{idx:02d}_{item}"
                    file_name = item.replace(" ", "_").replace("/", "_").replace("-", "_") + ".py"
                    file_path = os.path.join(current_path, file_name)
                    with open(file_path, 'w', encoding='utf-8') as file:
                        file.write(f"# {item}\n\n")
                        file.write(f'"""\nLecture: {parent_path}/{key}\nContent: {item}\n"""\n\n')

                    # 在README中添加文件链接
                    item_clean = item.replace(" ", "_").replace("/", "_").replace("-", "_")
                    parent_clean = parent_path.replace(" ", "_").replace("/", "_").replace("-", "_")
                    key_clean = key.replace(" ", "_").replace("/", "_").replace("-", "_")
                    readme_file.write(f"- [{item}](./{parent_clean}/{key_clean}/{item_clean}.py)\n")
                    
                    
                    file_name = item.replace(" ", "_").replace("/", "_").replace("-", "_") + ".md"
                    file_path = os.path.join(current_path, file_name)
                    with open(file_path, 'w', encoding='utf-8') as file:
                        file.write(f"# {item}\n\n")
                        file.write(f'"""\nLecture: {parent_path}/{key}\nContent: {item}\n"""\n\n')

                    # 在README中添加文件链接
                    item_clean = item.replace(" ", "_").replace("/", "_").replace("-", "_")
                    parent_clean = parent_path.replace(" ", "_").replace("/", "_").replace("-", "_")
                    key_clean = key.replace(" ", "_").replace("/", "_").replace("-", "_")
                    readme_file.write(f"- [{item}](./{parent_clean}/{key_clean}/{item_clean}.md)\n")
                    
        else:
            # 创建文件并写入初始内容
            file_name = key.replace(" ", "_").replace("/", "_").replace("-", "_") + ".py"
            file_path = os.path.join(current_path, file_name)
            with open(file_path, 'w', encoding='utf-8') as file:
                file.write(f"# {key}\n\n")
                file.write(f'"""\nLecture: {parent_path}/{key}\nContent: {key}\n"""\n\n')

            # 在README中添加文件链接
            parent_clean = parent_path.replace(" ", "_").replace("/", "_").replace("-", "_")
            key_clean = key.replace(" ", "_").replace("/", "_").replace("-", "_")
            readme_file.write(f"- [{key}](./{parent_clean}/{key_clean}/{file_name})\n")
            
            
            file_name = key.replace(" ", "_").replace("/", "_").replace("-", "_") + ".md"
            file_path = os.path.join(current_path, file_name)
            with open(file_path, 'w', encoding='utf-8') as file:
                file.write(f"# {key}\n\n")
                file.write(f'"""\nLecture: {parent_path}/{key}\nContent: {key}\n"""\n\n')

            # 在README中添加文件链接
            parent_clean = parent_path.replace(" ", "_").replace("/", "_").replace("-", "_")
            key_clean = key.replace(" ", "_").replace("/", "_").replace("-", "_")
            readme_file.write(f"- [{key}](./{parent_clean}/{key_clean}/{file_name})\n")
            

        # 添加空行以分隔不同的章节
        readme_file.write("\n")

def main():
    root_dir = './'
    # 创建根目录
    os.makedirs(root_dir, exist_ok=True)

    # 创建 README.md 文件
    with open(os.path.join(root_dir, "README.md"), 'w', encoding='utf-8') as readme_file:
        readme_file.write("# 算法导论\n\n")
        readme_file.write("这是一个关于算法导论的目录结构。\n\n")
        create_directories_and_files(root_dir, structure, readme_file)

    print("目录和文件结构已生成，并创建 README.md 文件。")

if __name__ == "__main__":
    main()